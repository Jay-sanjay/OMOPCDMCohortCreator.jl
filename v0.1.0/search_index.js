var documenterSearchIndex = {"docs":
[{"location":"api/#OMOPCDMCohortCreator-API","page":"API","title":"OMOPCDMCohortCreator API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"This is a list of documentation associated with every single exported function from OMOPCDMCohortCreator. There are a few different sections with a brief explanation of what these sections are followed by relevant functions.","category":"page"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/#Getters","page":"API","title":"Getters","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"This family of functions are dedicated to only getting information concerning a patient or OMOP CDM database.","category":"page"},{"location":"api/","page":"API","title":"API","text":"GetDatabasePersonIDs\nGetPatientState\nGetPatientGender\nGetPatientRace\nGetPatientAgeGroup\nGetPatientVisits\nGetMostRecentConditions\nGetMostRecentVisit\nGetVisitCondition","category":"page"},{"location":"api/#OMOPCDMCohortCreator.GetDatabasePersonIDs","page":"API","title":"OMOPCDMCohortCreator.GetDatabasePersonIDs","text":"GetDatabasePersonIDs(conn; tab::SQLTable = person)\n\nGet all unique person_id's from a database.\n\nArguments:\n\nconn - database connection using DBInterface\n\nKeyword Arguments:\n\ntab::SQLTable - the SQLTable representing the Person table; default person\n\nReturns\n\nids::Vector{Int64} - the list of persons\n\n\n\n\n\n","category":"function"},{"location":"api/#OMOPCDMCohortCreator.GetPatientState","page":"API","title":"OMOPCDMCohortCreator.GetPatientState","text":"GetPatientState(ids, conn; tab::SQLTable = location, join_tab::SQLTable = person)\n\nGiven a list of person IDs, find their home state.\n\nArguments:\n\nids - list of person_id's; each ID must be of subtype Integer conn - database connection using DBInterface\n\nKeyword Arguments:\n\ntab::SQLTable - the SQLTable representing the Location table; default location\njoin_tab::SQLTable - the SQLTable representing the Person table; default person\n\nReturns\n\ndf::DataFrame - a two column DataFrame comprised of columns: :person_id and :state\n\n\n\n\n\n","category":"function"},{"location":"api/#OMOPCDMCohortCreator.GetPatientGender","page":"API","title":"OMOPCDMCohortCreator.GetPatientGender","text":"GetPatientGender(ids, conn; tab::SQLTable = person)\n\nGiven a list of person IDs, find their gender.\n\nArguments:\n\nids - list of person_id's; each ID must be of subtype Integer conn - database connection using DBInterface\n\nKeyword Arguments:\n\ntab::SQLTable - the SQLTable representing the Person table; default person\n\nReturns\n\ndf::DataFrame - a two column DataFrame comprised of columns: :person_id and :gender_concept_id\n\n\n\n\n\n","category":"function"},{"location":"api/#OMOPCDMCohortCreator.GetPatientRace","page":"API","title":"OMOPCDMCohortCreator.GetPatientRace","text":"GetPatientRace(ids, conn; tab::SQLTable = person)\n\nGiven a list of person IDs, find their race.\n\nArguments:\n\nids - list of person_id's; each ID must be of subtype Integer conn - database connection using DBInterface\n\nKeyword Arguments:\n\ntab::SQLTable - the SQLTable representing the Person table; default person\n\nReturns\n\ndf::DataFrame - a two column DataFrame comprised of columns: :person_id and :race_concept_id\n\n\n\n\n\n","category":"function"},{"location":"api/#OMOPCDMCohortCreator.GetPatientAgeGroup","page":"API","title":"OMOPCDMCohortCreator.GetPatientAgeGroup","text":"GetPatientAgeGroup(     ids, conn;     minuend = :now,     age_groupings = [         [0, 9],         [10, 19],         [20, 29],         [30, 39],         [40, 49],         [50, 59],         [60, 69],         [70, 79],         [80, 89],     ],     tab::SQLTable = person, )\n\nFinds all individuals in age groups as specified by age_groupings.\n\nArguments:\n\nids - list of person_id's; each ID must be of subtype Integer\n\nage_groupings - a vector of age groups of the form [[10, 19], [20, 29],] denoting an age group of 10 - 19 and 20 - 29 respectively; age values must subtype of Integer\n\nconn - database connection using DBInterface\n\nKeyword Arguments:\n\nage_groupings - a vector of age groups of the form [[10, 19], [20, 29],] denoting an age group of 10 - 19 and 20 - 29 respectively; age values must subtype of Integer\nminuend - the year that a patient's year_of_birth variable is subtracted from; default :now. There are three different options that can be set: \n:now - the year as of the day the code is executed given in UTC time\n:db - the last year that any record was found in the database using the \"observation_period\" table (considered by OHDSI experts to have the latest records in a database)\nany year provided by a user as long as it is an Integer (such as 2022, 1998, etc.)\ntab::SQLTable - the SQLTable representing the Person table; default person\n\nReturns\n\ndf::DataFrame - a two column DataFrame comprised of columns: :person_id and :age_group\n\nNote\n\nAge can be difficult to be calculated consistently. In this case, there are some assumptions made to ensure consistency: \n\nAccording to the OMOP CDM v5.4, only the variable year_of_birth is guaranteed for a given patient. This is one of three options used as the minuend in age calculations.\nThe subtrahend is based on what one chooses for the minuend key word argument.\n\nThe age is then calculated following what is selected based on 1 and 2. This flexibility is encoded to allow a user to choose how they want age groups calculated as well as clear up an ambiguity on how this is determined.\n\n\n\n\n\n","category":"function"},{"location":"api/#OMOPCDMCohortCreator.GetPatientVisits","page":"API","title":"OMOPCDMCohortCreator.GetPatientVisits","text":"GetPatientVisits(ids, conn; tab::SQLTable = visit_occurrence)\n\nGiven a list of person IDs, find all their visits.\n\nArguments:\n\nids - list of person_id's; each ID must be of subtype Integer conn - database connection using DBInterface\n\nKeyword Arguments:\n\ntab::SQLTable - the SQLTable representing the Visit Occurrence table; default visit_occurrence\n\nReturns\n\ndf::DataFrame - a two column DataFrame comprised of columns: :person_id and :visit_occurrence_id\n\n\n\n\n\n","category":"function"},{"location":"api/#OMOPCDMCohortCreator.GetMostRecentConditions","page":"API","title":"OMOPCDMCohortCreator.GetMostRecentConditions","text":"GetMostRecentConditions(ids, conn; tab::SQLTable = condition_occurrence)\n\nGiven a list of person IDs, find their last recorded conditions.\n\nArguments:\n\nids - list of person_id's; each ID must be of subtype Integer conn - database connection using DBInterface\n\nKeyword Arguments:\n\ntab::SQLTable - the SQLTable representing the Condition Occurrence table; default condition_occurrence\n\nReturns\n\ndf::DataFrame - a two column DataFrame comprised of columns: :person_id and :condition_concept_id\n\n\n\n\n\n","category":"function"},{"location":"api/#OMOPCDMCohortCreator.GetMostRecentVisit","page":"API","title":"OMOPCDMCohortCreator.GetMostRecentVisit","text":"GetMostRecentVisit(ids, conn; tab::SQLTable = visit_occurrence)\n\nGiven a list of person IDs, find their last recorded visit.\n\nArguments:\n\nids - list of person_id's; each ID must be of subtype Integer conn - database connection using DBInterface\n\nKeyword Arguments:\n\ntab::SQLTable - the SQLTable representing the Visit Occurrence table; default visit_occurrence\n\nReturns\n\ndf::DataFrame - a two column DataFrame comprised of columns: :person_id and :visit_occurrence_id\n\n\n\n\n\n","category":"function"},{"location":"api/#OMOPCDMCohortCreator.GetVisitCondition","page":"API","title":"OMOPCDMCohortCreator.GetVisitCondition","text":"GetVisitCondition(visitids, conn; tab::SQLTable = visitoccurrence)\n\nGiven a list of visit IDs, find their corresponding conditions.\n\nArguments:\n\nvisit_ids - list of visit_id's; each ID must be of subtype Integer conn - database connection using DBInterface\n\nKeyword Arguments:\n\ntab::SQLTable - the SQLTable representing the Condition Occurrence table; default condition_occurrence\n\nReturns\n\ndf::DataFrame - a two column DataFrame comprised of columns: :visit_occurrence_id and :condition_concept_id\n\n\n\n\n\n","category":"function"},{"location":"api/#Filters","page":"API","title":"Filters","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"These functions accepts parameters to produce queries that look for specific subpopulations or information given specific patient identifier(s) (i.e. person_id). ","category":"page"},{"location":"api/","page":"API","title":"API","text":"VisitFilterPersonIDs\nConditionFilterPersonIDs\nRaceFilterPersonIDs\nGenderFilterPersonIDs\nStateFilterPersonIDs\nAgeGroupFilterPersonIDs","category":"page"},{"location":"api/#OMOPCDMCohortCreator.VisitFilterPersonIDs","page":"API","title":"OMOPCDMCohortCreator.VisitFilterPersonIDs","text":"VisitFilterPersonIDs(visitcodes, conn; tab::SQLTable = visitoccurrence)\n\nGiven a list of visit concept IDs, visit_codes return from the database patients matching at least one of the provided visit codes from the Visit Occurrence table.\n\nArguments:\n\nvisit_codes - a vector of visit_concept_id's; must be a subtype of Integer\n\nconn - database connection using DBInterface\n\nKeyword Arguments:\n\ntab::SQLTable - the SQLTable representing the Visit Occurrence table; default visit_occurrence\n\nReturns\n\nids::Vector{Int64} - the list of persons resulting from the filter\n\n\n\n\n\n","category":"function"},{"location":"api/#OMOPCDMCohortCreator.ConditionFilterPersonIDs","page":"API","title":"OMOPCDMCohortCreator.ConditionFilterPersonIDs","text":"ConditionFilterPersonIDs(conditioncodes, conn; tab::SQLTable = conditionoccurrence)\n\nGiven a list of condition concept IDs, condition_codes, return from the database individuals having at least one entry in the Condition Occurrence table matching at least one of the provided condition types.\n\nArguments:\n\ncondition_codes - a vector of condition_concept_id's; must be a subtype of Integer\n\nconn - database connection using DBInterface\n\nKeyword Arguments:\n\ntab::SQLTable - the SQLTable representing the Condition Occurrence table; default condition_occurrence\n\nReturns\n\nids::Vector{Int64} - the list of persons resulting from the filter\n\n\n\n\n\n","category":"function"},{"location":"api/#OMOPCDMCohortCreator.RaceFilterPersonIDs","page":"API","title":"OMOPCDMCohortCreator.RaceFilterPersonIDs","text":"RaceFilterPersonIDs(race_codes, conn; tab::SQLTable = person)\n\nGiven a list of condition concept IDs, race_codes, return from the database individuals having at least one entry in the Person table matching at least one of the provided race types.\n\nArguments:\n\nrace_codes - a vector of race_concept_id's; must be a subtype of Integer\n\nconn - database connection using DBInterface\n\nKeyword Arguments:\n\ntab::SQLTable - the SQLTable representing the Person table; default person\n\nReturns\n\nids::Vector{Int64} - the list of persons resulting from the filter\n\n\n\n\n\n","category":"function"},{"location":"api/#OMOPCDMCohortCreator.GenderFilterPersonIDs","page":"API","title":"OMOPCDMCohortCreator.GenderFilterPersonIDs","text":"GenderFilterPersonIDs(gendercodes, conn; tab::SQLTable = visitoccurrence)\n\nGiven a list of visit concept IDs, gender_codes return from the database individuals having at least one entry in the Person table matching at least one of the provided gender types.\n\nArguments:\n\nvisit_codes - a vector of gender_concept_id's; must be a subtype of Integer\n\nconn - database connection using DBInterface\n\nKeyword Arguments:\n\ntab::SQLTable - the SQLTable representing the Person table; default person\n\nReturns\n\nids::Vector{Int64} - the list of persons resulting from the filter\n\n\n\n\n\n","category":"function"},{"location":"api/#OMOPCDMCohortCreator.StateFilterPersonIDs","page":"API","title":"OMOPCDMCohortCreator.StateFilterPersonIDs","text":"StateFilterPersonIDs(states, conn; tab::SQLTable = location, join_tab::SQLTable = person)\n\nGiven a list of states, states, return from the database individuals found in the provided state list.\n\nArguments:\n\nstates - a vector of state abbreviations; must be a subtype of AbstractString\n\nconn - database connection using DBInterface\n\nKeyword Arguments:\n\ntab::SQLTable - the SQLTable representing the Location table; default location\njoin_tab::SQLTable - the SQLTable representing the Person table; default person\n\nReturns\n\nids::Vector{Int64} - the list of persons resulting from the filter\n\n\n\n\n\n","category":"function"},{"location":"api/#Generators","page":"API","title":"Generators","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The generator functions are to set generate initial connections to an OMOP CDM database or to finalize resulting data from queries into various outputs. ","category":"page"},{"location":"api/","page":"API","title":"API","text":"# GenerateCohorts\nGenerateDatabaseDetails\nGenerateGroupCounts\n# GenerateStudyPopulation \nGenerateTables","category":"page"},{"location":"api/#OMOPCDMCohortCreator.GenerateDatabaseDetails","page":"API","title":"OMOPCDMCohortCreator.GenerateDatabaseDetails","text":"GenerateDatabaseDetails(dialect::Symbol, schema::String)\n\nGenerates the dialect and schema details for accessing a given OMOP CDM database.\n\nArguments:\n\ndialect::Symbol - the dialect used for SQL queries (to see what is dialects are available, see here: https://mechanicalrabbit.github.io/FunSQL.jl/stable/reference/#FunSQL.SQLDialect)\nschema::String - the name of the database schema being used.\n\n\n\n\n\n","category":"function"},{"location":"api/#OMOPCDMCohortCreator.GenerateGroupCounts","page":"API","title":"OMOPCDMCohortCreator.GenerateGroupCounts","text":"GenerateGroupCounts(data::DataFrame)\n\nGiven data in a DataFrame, get group counts based on each feature found in the DataFrame and removes person_id for privacy aggregation purposes.\n\nArguments:\n\ndata::DataFrame - a DataFrame that must have at least a person_id column\n\nReturns:\n\ndf::DataFrame - a DataFrame that contains the group counts based on each feature found in data with the person_id field removed for privacy\n\n\n\n\n\n","category":"function"},{"location":"api/#OMOPCDMCohortCreator.GenerateTables","page":"API","title":"OMOPCDMCohortCreator.GenerateTables","text":"GenerateTables(conn; inplace = true, exported = false)\n\nGenerates Julia representations of all tables found in a given OMOP CDM database.\n\nArguments:\n\ndialect::Symbol - the dialect used for SQL queries (to see what is dialects are available, see here: https://mechanicalrabbit.github.io/FunSQL.jl/stable/reference/#FunSQL.SQLDialect)\nschema::String - the name of the database schema being used.\n\n\n\n\n\n","category":"function"},{"location":"api/#Executors","page":"API","title":"Executors","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"These functions perform quality assurance checks on data extracts genereated from OMOPCDMCohortCreator queries.","category":"page"},{"location":"api/","page":"API","title":"API","text":"ExecuteAudit","category":"page"},{"location":"api/#OMOPCDMCohortCreator.ExecuteAudit","page":"API","title":"OMOPCDMCohortCreator.ExecuteAudit","text":"TODO: Add docs when ready\n\n\n\n\n\n","category":"function"},{"location":"tutorials/#Tutorials","page":"Tutorials","title":"Tutorials","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"","category":"page"},{"location":"tutorials/#Beginner-Tutorial","page":"Tutorials","title":"Beginner Tutorial","text":"","category":"section"},{"location":"tutorials/#Environment-Set-Up","page":"Tutorials","title":"Environment Set-Up","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"For this tutorial, you will need to activate an environment; to get into package mode within your Julia REPL, write ]:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"pkg> activate TUTORIAL","category":"page"},{"location":"tutorials/#Packages","page":"Tutorials","title":"Packages","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"You will need the following packages for this tutorial which you can install in package mode:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"TUTORIAL> add OMOPCDMCohortCreator\nTUTORIAL> add OMOPCDMDatabaseConnector\nTUTORIAL> add SQLite\nTUTORIAL> add DataFrames\nTURORIAL> add HealthSampleData","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"NOTE: For HealthSampleData, the package is in the process of being registered so for now, you may have to instead do if the add command fails.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"TUTORIAL> add https://github.com/JuliaHealth/HealthSampleData.jl","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"<!–TODO: Add descriptions on what these packages are and what they are for –>","category":"page"},{"location":"tutorials/#Data","page":"Tutorials","title":"Data","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"For this tutorial, we will work with data from Eunomia that is stored in a SQLite format. To install the data on your machine, execute the following code block and follow the prompts - you will need a stable internet connection for the download to complete: ","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"using HealthSampleData\n\neunomia = Eunomia()","category":"page"},{"location":"tutorials/#Connecting-to-the-Eunomia-Database","page":"Tutorials","title":"Connecting to the Eunomia Database","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"After you have finished your set up in the Julia, we need to establish a connection to the Eunomia SQLite database that we will use for the rest of the tutorial: ","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"using SQLite\n\nconn = SQLite.DB(eunomia)","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"With Eunomia, the database's schema is simply called \"main\". We will use this to generate database connection details that will inform OMOPCDMCohortCreator about the type of queries we will write (i.e. SQLite) and the name of the database's schema. For this step, we will use OMOPCDMCohortCreator and OMOPCDMDatabaseConnector:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"using OMOPCDMCohortCreator\nusing OMOPCDMDatabaseConnector\n\nGenerateDatabaseDetails(\n    :sqlite,\n    \"main\"\n)","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Finally, we will generate internal representations of each table found within Eunomia for OMOPCDMCohortCreator to use:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"GenerateTables(conn)","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"As a check to make sure everything was correctly installed and works properly, the following block should work and return a list of all person ids in this data:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"GetDatabasePersonIDs(conn)","category":"page"},{"location":"tutorials/#Characterizing-Patients-Who-Have-Had-Strep-Throat","page":"Tutorials","title":"Characterizing Patients Who Have Had Strep Throat","text":"","category":"section"},{"location":"tutorials/#Background","page":"Tutorials","title":"Background","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"As all the tools are working properly, let's do what is called a characterization study - a study that characterizes a group of patients with a certain condition (or conditions) across various attributes like race, age, and combinations thereof. We are going to do miniature version of such a study looking at patients with strep throat. For this, we will use the condition_concept_id: 28060 - this will be needed for you to get correct results.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"NOTE: As we go through this example, do not immediately jump to the code block required but try to use the API to come up with solutions as there may be more than one answer.","category":"page"},{"location":"tutorials/#Task:-Find-All-Patients-with-Strep-Throat","page":"Tutorials","title":"Task: Find All Patients with Strep Throat","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Using the API, find all patients with strep throat.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Suggested solution:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"strep_patients = ConditionFilterPersonIDs(28060, conn)","category":"page"},{"location":"tutorials/#Task:-Find-the-Race-of-Patients-with-Strep-Throat","page":"Tutorials","title":"Task: Find the Race of Patients with Strep Throat","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"For the patients who have strep throat diagnoses, find their race.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Suggested solution:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"strep_patients_race = GetPatientRace(strep_patients, conn)","category":"page"},{"location":"tutorials/#Task:-Find-the-Gender-of-Patients-with-Strep-Throat","page":"Tutorials","title":"Task: Find the Gender of Patients with Strep Throat","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"For the patients who have strep throat diagnoses, find their gender.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Suggested solution:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"strep_patients_gender = GetPatientGender(strep_patients, conn)","category":"page"},{"location":"tutorials/#Task:-Create-Age-Groupings-of-Patients-with-Strep-Throat","page":"Tutorials","title":"Task: Create Age Groupings of Patients with Strep Throat","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"For this task, for every single person who has a strep throat diagnosis, assign them an age group. The age groupings must follow 5 year intervals when assigned to a person up to 100 years of age (e.g. 0 4 5 9  95 100).","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Suggested solution:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"age_groups = [\n\t[0, 4],\n\t[5, 9],\n\t[10, 14],\n\t[15, 19],\n\t[20, 24],\n\t[25, 29],\n\t[30, 34],\n\t[35, 39],\n\t[40, 44],\n\t[45, 49],\n\t[50, 54],\n\t[55, 59],\n\t[60, 64],\n\t[65, 69],\n\t[70, 74],\n\t[75, 79],\n\t[80, 84],\n\t[85, 89],\n\t[90, 94],\n\t[95, 99]\n]\nstrep_patients_age_group = GetPatientAgeGroup(strep_patients, conn; age_groupings = age_groups)","category":"page"},{"location":"tutorials/#Task:-Characterize-Each-Person-by-Gender,-Race,-and-Age-Group","page":"Tutorials","title":"Task: Characterize Each Person by Gender, Race, and Age Group","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"With the previous tasks, we now know patients' gender, race, and age group. Using this information, combine these features to create a final table where each patient's person_id, gender, race, and age group is found in a given row. Hint: The DataFrames.jl documentation section on joins will be of strong use here.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Suggested solution:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"using DataFrames\n\nstrep_patients_characterized = outerjoin(strep_patients_race, strep_patients_gender, strep_patients_age_group; on = :person_id, matchmissing = :equal)\nstrep_patients_age_group = GetPatientAgeGroup(strep_patients)","category":"page"},{"location":"tutorials/#Task:-Create-Patient-Groupings","page":"Tutorials","title":"Task: Create Patient Groupings","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Often with characterization style studies, it is extremely important to aggregate patient populations. Why? To protect the anonymity of patients with perhaps severely sensitive conditions (e.g. mental illnesses, sexually transmitted diseases, etc.) from possible repercussions from accidental disclosure of this patient information.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"For this task, add to the table you created in the previous task a new column called counts and remove the person_id column. The counts column should represent the total number of patients belonging to a group's gender, race, and age group. Here is an example on how to calculate counts: if there are 5 rows in your table that have patients who are between the ages of 20 - 24, are African American, and are female, the value for that age, race, and gender group is 5. The 5 rows would then collapse into 1 row as unique patient identifiers (the person_id column) would be removed. Hint: removing the person_id column first may make things easier; also, look at the DataFrames.jl documentation on the Split-Apply-Combine approach to generate the counts column.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Suggested solution:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"strep_patients_characterized = strep_patients_characterized[:, Not(:person_id)]\nstrep_patient_groups = groupby(strep_patients_characterized, [:race_concept_id, :gender_concept_id, :age_group])\nstrep_patient_groups = combine(strep_patient_groups, nrow => :counts)","category":"page"},{"location":"tutorials/#Conclusion","page":"Tutorials","title":"Conclusion","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"This mini characterization study that we just conducted on this dataset opens up a whole new avenue for a researcher to pursue. For example, we could now calculate prevalence rates across different patient characteristics or compare and contrast multiple conditions at once. It should also be apparent that the API is set up in a very particular way: it is functional meaning that each function does one thing only. This gives a lot of flexibility to a user to build together study incrementally using OMOPCDMCohortCreator. Congratulations on finishing this tutorial and if there are any issues you encountered, feel free to open an issue here!","category":"page"},{"location":"#Welcome-to-the-OMOPCDMCohortCreator.jl-Docs!","page":"Home","title":"Welcome to the OMOPCDMCohortCreator.jl Docs!","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Create cohorts from databases utilizing the OMOP CDM.","category":"page"},{"location":"","page":"Home","title":"Home","text":"These docs are a work in progress! 😀 To get started, visit the Tutorials section as well as visit the API section to see all the functions available.","category":"page"}]
}
